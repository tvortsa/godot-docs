.. _doc_custom_drawing_in_2d:

Собственное рисование в 2D
==========================

Зачем?
------

Godot обладает узлами для отрисовки спрайтов, полигонов, частиц, и
всего остального. Для большинства ситуаций этого достаточно, но не всегда.
Если что-то из того что вам нужно не поддерживается, не расстраивайтесь
из-за того что нет узла делающего-то-что-вам-надо... 
Все можно нарисовать просто создав 2D node (будь это
:ref:`Control <class_Control>` или :ref:`Node2D <class_Node2D>`
based) и задав пользовательские команды рисования. 
Это *действительно* не сложно.

Но...
------

Пользовательский рисунок вручную в узле *реально* здорово. И вот почему:

-  Отрисовка форм или логики которая не обрабатывается узлами (пример: 
   создание узла который рисует круг, изображение со следом (типа хвост кометы),
   особые случаи анимированных полигонов, и т.п.).
-  Визуализации, которые не совместимы с узлами: (пример: доска тетриса).
   Пример тетриса использует собственную функцию отрисовки блоков.
-  Управление логикой рисования большого количества простых объектов
   (сотни и тысячи). Использование тысяч узлов далеко не так эффективно
   как отрисовка, но тысяча вызовов отрисовки это не много.
   Посмотрите пример демо "Shower of Bullets".
-  Создание собственного UI control. Есть много готовых элементов управления,
   Но можно легко столкнуться с необходимостью создания нового, нестандартного.

OK, как?
--------

Добавьте скрипт к любому :ref:`CanvasItem <class_CanvasItem>`
derived node, типа :ref:`Control <class_Control>` или
:ref:`Node2D <class_Node2D>`. Замените функцию _draw().

::

    extends Node2D

    func _draw():
        #ваши собственные команды отрисовки
        pass

Команды рисования описаны здесь :ref:`CanvasItem <class_CanvasItem>`.
Их много.

Обновление
----------

Функция _draw() вызывается лишь однажды, затем команды рисования
кэшируются и запоминаются, поэтому повторные вызовы не нужны.

Если нужно пере-рисовать потому что что-то изменилось,
просто вызовите :ref:`CanvasItem.update() <class_CanvasItem_update>`
в этом же узле и произойдет новый вызов _draw().

Вот немного более сложный пример. Текстурная переменная, которая будет
перерисовываться при изменении:

::

    extends Node2D

    export var texture setget _set_texture

    func _set_texture(value):
        #если текстурная переменная изменена извне,
        #вызываем этот коллбэк.
        texture=value #текстура была изменена
        update() #обновление этого узла

    func _draw():
        draw_texture(texture,Vector2())

Иногда бывает нужно перерисовывать в каждом кадре. Для этого, просто
вызывайте update() из коллбэка _process() , вот так:

::

    extends Node2D

    func _draw():
        #ваши команды рисования
        pass

    func _process(delta):
        update()

    func _ready():
        set_process(true)

Например: рисуем круговую арку
-------------------------------

Теперь мы будем использовать пользовательские функции рисования Godot Engine для отрисовки чего в Godot нет готовой функции. Как например, Godot имеет функцию draw_circle() которая рисует полный круг. Но, что если вам нужна только часть круга? Для этого мы напишем собственный код и функцию, и сами отрисуем все.

Функция дуги
^^^^^^^^^^^^


Дуга определяется своими параметрами опорного круга, то есть: позиция центра, и радиус. А также значение угла с которого она начинает рисоваться и угла на котором заканчивается. Вот те 4 параметра которые понадобяться нашей функции отрисовки. Мы также предоставим значение цвета, чтобы можно было рисовать дугу разным цветом.

В основе своей, рисование фигур на экране требует ее разложения на определенное количество точек выстроенных одна за другой. Чем больше точек требуется вашей фоме тем более гладкой она выглядит, но тем сложнее процессору ее вычислять. Обычно, если форма огромная (или в 3D, ближе к камере), тем больше точек она потребует без учета вида под углом. С другой стороны, если ваша форма маленькая (или в 3D,  далеко от камеры), вы можете сократить количество точек и удешевить отрисовку формы. Это называют уровнем детализации *Level of Detail (LoD)*. В нашем примере, мы будем просто использовать фиксированное количество точек, вне зависимости от радиуса.

::

    func draw_circle_arc( center, radius, angle_from, angle_to, color ):
        var nb_points = 32
        var points_arc = Vector2Array()
    
        for i in range(nb_points+1):
            var angle_point = angle_from + i*(angle_to-angle_from)/nb_points - 90
            var point = center + Vector2( cos(deg2rad(angle_point)), sin(deg2rad(angle_point)) ) * radius
            points_arc.push_back( point )
    
        for indexPoint in range(nb_points):
            draw_line(points_arc[indexPoint], points_arc[indexPoint+1], color)

Помните про точки на которые нам надо было разложить форму? Мы зададим их количество в переменной nb_points используя фиксированное значение - 32. Затем инициализирцем пустой массив Vector2Array, это просто массив типа Vector2.

Следующим шагом будет вычисление реальных координат этих 32 точек составляющих нашу дугу. Это выполняется в первом цикле for: мы проходим по всем точкам позиции которых хотим вычислить, плюс одна последняя точка. Сперва мы вычисляем угол каждой точки между стартовым и конечным углами. 

Причина, почему каждый угол уменьшается на 90° в том, что мы будем вычислять 2D позиции для каждого угла с помощью тригонометрии (ну, знаете, синус-косинус...). Но чтобы упростить, cos() и sin() используют радианы, не градусы. Угол в 0° (0 радиан) начинается на три часа, а мы хотим начать отсчет от ноль часов. Поэтому мы просто сокращаем каждый угол на 90° чтобы отсчет шел от ноля часов.

Фактическое положение точки, расположенной по кругу под углом 'angle' (в радианах) задается в Vector2(cos(angle), sin(angle)). Поскольку cos() и sin() возвращают значение между -1 и 1, позиция задается на круге с радиусом 1. Чтобы получить позицию на заданном опорном круге, радиус которого задан в 'radius', нужно просто умножить позицию на 'radius'. Наконец, нам нужно расположитьнаш опорный круг в позицию 'center', что достигается сложением его с нашим значением Vector2. Наконец, мы вставим точку в Vector2Array который объявили ранее.

Теперь нужно отрисовать наши точки. Как вы понимаете, мы не можем просто отрисовать 32 точки: нам нужно отрисовать и все, что между каждой из них. Мы могли бы вычислить каждую точку сами используя предыдущий способ, и отрисовать их по-одной, но это очень сложно и не эффективно (кроме случаев когда вам именно это и нужно). Итак, мы просто отрисуем прямые линии между каждой парой точек. Если радиус опорного круга небольшой, длина каждой линии между парой точек никогда не будет достаточной длины чтобы быть заметной. Если это произошло, нужно просто увеличить количество точек.

Отрисовка дуги на экране
^^^^^^^^^^^^^^^^^^^^^^^^
Теперь у нас есть функция которая рисует на экране: настало время вызвать ее в функции _draw().

::

    func _draw():
        var center = Vector2(200,200)
        var radius = 80
        var angle_from = 75
        var angle_to = 195
        var color = Color(1.0, 0.0, 0.0)
        draw_circle_arc( center, radius, angle_from, angle_to, color )

Result:

.. image:: /img/result_drawarc.png



Функция полигональной дуги
^^^^^^^^^^^^^^^^^^^^^^^^^^
Мы можем сделать еще один шаг и написать функцию, которая рисует гладкую часть диска, определяемую дугой, а не только ее форму. Метод точно такой же, как и ранее, за исключением того, что мы рисуем многоугольник вместо линий:

::

    func draw_circle_arc_poly( center, radius, angle_from, angle_to, color ):
        var nb_points = 32
        var points_arc = Vector2Array()
        points_arc.push_back(center)
        var colors = ColorArray([color])
    
        for i in range(nb_points+1):
            var angle_point = angle_from + i*(angle_to-angle_from)/nb_points - 90
            points_arc.push_back(center + Vector2( cos( deg2rad(angle_point) ), sin( deg2rad(angle_point) ) ) * radius)
        draw_polygon(points_arc, colors)
        
        
.. image:: /img/result_drawarc_poly.png

Динамическое кастомное рисование
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Итак, теперь мы можем нарисовать что-то свое на экране. Но, все это статично: давайте заставим эту фигуру вращаться вокруг центра. Для этого нам нужно просто изменять значения angle_from и angle_to все время. Для нашего примера, мы просто будем увеличивать на 50. Это значение приращения должно оставаться постоянным, иначе скорость вращения будет меняться соответственно.

Во-првых, мы должны сделать так чтобы переменные angle_from и angle_to глобальными в начале нашего скрипта. Также обратите внимание, что вы можете хранить их в других узлах и обращаться к ним используя get_node().

::

 extends Node2D

 var rotation_ang = 50
 var angle_from = 75
 var angle_to = 195



Мы изменяем эти значения в функции _process(delta). Для активации этой функции, нам нужно вызвать set_process(true) в функции _ready() . 

Здесь мы также инкрементируем значения angle_from и angle_to. Но, не забывайте wrap() полученные значения между 0 и 360°! То есть, если угол равен 361°, то в действительности это 1°. Если вы не wrap эти значения, скрипт будет работать корректно но но величина угла будет все время нарастать, пока не привысит допустимый предел в Godot который равен (2^31 - 1). Когда это произойдет, Godot может крашнуться или выдать неожиданное поведение. Поскольку Godot не предоставляет функцию wrap(), мы создадим ее здесь, поскольку это отномительно просто.

И наконец, незабудьте вызвать функцию update(), которая автоматически вызовет _draw(). Таким образом, таким образом вы сможете управлять тем, когда вы хотите рефрешнуть кадр.

::

 func _ready():
     set_process(true)
 
 func wrap(value, min_val, max_val):
     var f1 = value - min_val
     var f2 = max_val - min_val
     return fmod(f1, f2) + min_val

 func _process(delta):
     angle_from += rotation_ang
     angle_to += rotation_ang
     
     # we only wrap angles if both of them are bigger than 360
     if (angle_from > 360 && angle_to > 360):
         angle_from = wrap(angle_from, 0, 360)
         angle_to = wrap(angle_to, 0, 360)
     update()

Также, не забудьте модифицировать функцию _draw() на использование этих переменных:
::

 func _draw():
	var center = Vector2(200,200)
	var radius = 80
	var color = Color(1.0, 0.0, 0.0)

	draw_circle_arc( center, radius, angle_from, angle_to, color )

Теперь запустим!
Работает, Но дуга вращается безумно быстро! Что не так?

Дело в том что ваш GPU старается отображать кадры как можно быстрее. Нам нужно "нормализовать" отрисовку по его скорости. Для чего, используют параметр 'delta' функции _process(). 'delta' содержит время, прошедшее между двумя последними отрендеренными кадрами. Обычно это очень мало (около 0.0003 секунды, но это зависит от вашего железа). Итак, использование 'delta' для управления отрисовкой обеспечивает одинаковую скорость вашей игры на любом железе.

В нашем случае, нам нужно просто умножить значение переменной 'rotation_ang' на 'delta' в функции _process(). Таким образом, наши 2 угла будут увеличиваться на гораздо меньшее значение, напрямую зависящее от скорости рендеринга.

::

 func _process(delta):
     angle_from += rotation_ang * delta
     angle_to += rotation_ang * delta
     
     # мы wrap углы только если они оба больше 360
     if (angle_from > 360 && angle_to > 360):
         angle_from = wrap(angle_from, 0, 360)
         angle_to = wrap(angle_to, 0, 360)
     update()

Запустим снова! Теперь, вращение выглядит правильно!

Tools
-----

Вы можете захотеть отрисовку ваших собственных узлов прямо в редакторе
, чтобы использовать в качестве предварительного просмотра или визуализации
некоторых функций или поведения.

Помните просто используйте ключевое слово "tool" в начале скрипта
(см. руководство :ref:`doc_gdscript` если позабыли об этом).
