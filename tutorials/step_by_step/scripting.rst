.. _doc_scripting:

Скриптинг
=========

Введение
------------

Мы много говорили об инструментах которые позволяют обойтись без программирования.
Это мечта многих разработчиков - программировать игры без обучения кодингу.
Эта потредность есть даже внутри компаний в которых разработчики хотели бы больше контроля
над потоком игры .

Многие обещают среду без программирования, но чаще всего результат оказывается неполным, 
слишком сложным и неэффективным по сравнению с классическим кодингом. 
Так что программирование сохраниться еще надолго. Общее направление развития
игровых систем в том чтобы дать инструменты сокращающие необходимость написания кода
для типовых задач.

Поэтому, Godot принял пару важных решений. Во-первых система сцен. Она облегчает
программисту зависимость от архитектуры.

При азработке игр с использованием системы сцен, весь проект фрагментирован на 
*комплкментарные* сцены (а не отдельные). Сцены составляют друг друга,вместо того 
чтобы быть раздельными. 

Имеющие опыт знают о чем-то вроде MVC. Godot обещает эффективность без привычного MVC
заменяя его на паттерн *сцены как составляющие*.

Godot также использует паттерн  `extend <http://c2.com/cgi/wiki?EmbedVsExtend>`__
для скриптинга, это означает что скрипты доступны для всех доступных классов движка.

GDScript
--------

:ref:`doc_gdscript` это динамически типизированный скриптовый язык работающий
внутри Godot. Он разработан с прицелом на:

-  Быть простым и узнаваемым на сколько это возможно.
-  Создаваемый код читабелен и безопасен. Синтаксис в основном заимствован из Python.

Программистам обычно нужно пара дней чтобы выучить его, и пару недель на комфортное освоение.

Как и большинство типизированных языков, удобство
(простота чтения кода, скорость написания, остутствие компиляции, и т.п.)
это компромис с потерей производительности. Но основной критический код 
написан на C++ прямо в движке (vector ops, physics, math, indexing, etc),
в результате его производительности более чем достаточно для большинства
типов игр.

В любом случае, если необходимо больше производительности, критические разделы
можно переписать на C++ и exposed прозрачно в script. Это позволяет заменить
GDScript класс на C++ класс без изменения остальной игры.

Скриптинг сцены
-----------------

Перед тем как продолжить, обязательно прочтите справку по :ref:`doc_gdscript`.
Это простой язык и справочное по нему короткое, это не займет дольше нескольких минут
и позволит ознакомиться с основными концепциями.

Настройка сцены
~~~~~~~~~~~

Урок начинается со скриптинга небольшой GUI сцены. Используйте окно добавления узла
для создания следующей иерархии со следующими узлами:

- Panel

  * Label
  * Button

Это должно выглядеть примерно так:

.. image:: /img/scripting_scene_tree.png

Используйте 2D редактор чтобы расположить и масштабировать кнопку и label 
так как на картинке. Можете задать text на панели Inspector.

.. image:: /img/label_button_example.png

Сохраните сцену, с названием "sayhello.scn"

.. _doc_scripting-adding_a_script:

Добавление скрипта
~~~~~~~~~~~~~~~

Правым кликом на панели node, в контекстном меню выберите "Add Script" :

.. image:: /img/add_script.png

Появится окно создания скрипта. Это окно позволяет выбрать язык, имя класса, и т.п.
GDScript не использует имена классов в файле скрипта, так что это поле не редактируемо.
Скрипт должен наследовать от "Panel" (это значит расширить узел, который имеет тип Panel,
это заполняется автоматически).

Введите path name для скрипта и затем нажмите "Create":

.. image:: /img/script_create.png

После чего, скрипт должен создасться и добавиться к узлу. 
Это видно как дополнительный значок на узле, а также как свойство script:

.. image:: /img/script_added.png

Редактировать этот скрипт можно либо выбрав подсвеченную кнопку. 
Это перенесет вас в редактор скрипта в который включается шаблон по-умолчанию:

.. image:: /img/script_template.png

Там не так много. Функция "_ready()" вызывается когда узел (и все его потомки)
вошли в активную сцену. (Помните, это НЕ конструктор !, конструктор это "_init()" ).

Роль скрипта
~~~~~~~~~~~~~~~~~~~~~~

Скрипт добавляет узлу поведение. Его используют для управления
функционалом узла или других узлов (дочерних, родительских, сродных (соседних), и т.п.).
Локальная область действия скрипта это узел (также как в обычном наследовании) 
и виртуальные функции узла захватываются скриптом.

.. image:: /img/brainslug.jpg

Обработка сигналов
~~~~~~~~~~~~~~~~~

Сигналы больше всего используются в узлах GUI (хотя и другие узлы тоже их имеют).
Сигналы "испускаются" когда происходят какие-то виды действиий,
и могут быть подключены к любой функции любого экземпляра скрипта.
На данном этапе, сигнал "pressed" из кнопки будет соединен с произвольной функцией.

Интерфейс для соединения сигналов с вашим скриптом есть в редакторе. 
Для доступа к нему выделите узел в дереве сцены затем вкладку "Node".
Убедитесь что выделили "Signals".

.. image:: /img/signals.png

В любом случае, сейчас понятно что мы заинтересованы в сигнале
 "pressed". Вместо визуального интерфейса, мы выберем кодировать соединение.

Для чего, существует возможно самая используемая программистами Godot функция,
по имени :ref:`Node.get_node() <class_Node_get_node>`.
Эта функция использует пути для извлечения узлов из текущего дерева где угодно на сцене,
по отношению к узлу со сценарием.

Чтобы извлечь кнопку, используйте:

::

    get_node("Button")

Затем, будет добавлен обратный вызов который изменит текст метки при нажатии
кнопки:

::

    func _on_button_pressed():  
        get_node("Label").set_text("HELLO!")

Наконец, сигнал "pressed" кнопки будет соединен с этим обратным вызовом
in _ready(), используя :ref:`Object.connect() <class_Object_connect>`.

::

    func _ready():
        get_node("Button").connect("pressed",self,"_on_button_pressed")

Итоговый скрипт будет выглядеть так:

::

    extends Panel

    # member variables here, example:

    # var a=2
    # var b="textvar"

    func _on_button_pressed():
        get_node("Label").set_text("HELLO!")

    func _ready():
        get_node("Button").connect("pressed",self,"_on_button_pressed")

Запустите сцену и получите ожидаемый результат:

.. image:: /img/scripting_hello.png

**Note:** Есть распространенное заблуждение в данном руководстве, 
давайте проясним еще раз что get_node(path) работает путем возврата *немедленно*
потомка узла управляемого скриптом (в данном случае, *Panel*), поэтому *Button*
должен быть потомком *Panel* чтобы код заработал. Поясним, если бы *Button*
был потомком *Label*, то код был бы таким:

::

    # не в нашем случае
    # но где-то может быть так
    get_node("Label/Button") 

Также помните что к узлам обращаются по имени а не по типу.
