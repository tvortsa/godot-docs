.. _doc_scripting_continued:

Scripting (продолжение)
=====================

Процессинг
----------

Некоторые действия в Godot выполняют обратными вызовами или виртуальными функциями,
поэтому нет необходимости проверять написание кода запускаемого все время. 
Кроме того, многое может быть сделано с помощью анимаций игроков.

Однако, все еще остается распротраненным ситуация когда нужен скрипт
выполняющийся в каждом кадре. Есть два типа процессинга, idle процессинг
и fixed процессинг.

Idle процессинг активируется с помощью функции
:ref:`Node.set_process() <class_Node_set_process>`
После активации, обратный вызов:ref:`Node._process() <class_Node__process>`
будет вызываться в каждом кадре. Пример:

::

    func _ready():
        set_process(true)

    func _process(delta):
        # do something...

Параметр delta описывает время, прошедшее (в секундах, как значение 
с плавающей точкой) с момента предыдущего вызова to _process().
Fixed процессинг похож, но он необходим только для синхронизации с физическим движком.

Простой способ протестировать это - создать сцену с единственным узлом Label,
со следующим скриптом:

::

    extends Label

    var accum=0

    func _ready():
        set_process(true)

    func _process(delta):
        accum += delta
        set_text(str(accum))

Мы увидим счетчик инкрементирующий в каждом кадре.

Группы
------

Узлы можно добавлять в группы (сколько угодно для каждого узла).
это простая но полезная функция для организации больших сцен. 
Есть два способа сделать это, первый из UI, по кнопке Groups в панели Node:

.. image:: /img/groups_in_nodes.PNG

А второй - в коде. Один из полезных примеров - 
помечать сцены которые будут врагами.

::

    func _ready():
        add_to_group("enemies")

Так, если игрок проникнет на секрентую базу,
все враги могут быть уведомлены звуком сирены, с помощью:
:ref:`SceneTree.call_group() <class_SceneTree_call_group>`:

::

    func _on_discovered():
        get_tree().call_group(0, "guards", "player_was_discovered")

Этот код вызывает функцию "player_was_discovered" каждого члена группы "guards".

Опционально, можно получить полный список узлов "guards" вызовом:

:ref:`SceneTree.get_nodes_in_group() <class_SceneTree_get_nodes_in_group>`:

::

    var guards = get_tree().get_nodes_in_group("guards")

Больше будет добавлено позже
:ref:`SceneTree <class_SceneTree>`


Уведомления
-------------

Godot имеет систему уведомлений. Она обычно не нуждается в скриптинге,
поскольку довольно низкоуровневая и и для большинства из них
предусмотрены виртуальные функции. Просто хорошо знать что они есть.
Просто
:ref:`Object._notification() <class_Object__notification>`
 добавьте функцию в ваш скрипт:

::

    func _notification(what):
        if (what == NOTIFICATION_READY):
            print("This is the same as overriding _ready()...")
        elif (what == NOTIFICATION_PROCESS):     
            var delta = get_process_time()
            print("This is the same as overriding _process()...")

Документация по каждому классу :ref:`Class Reference <toc-class-ref>`
содержит уведомления которые он может принимать. Но, для большинства случаев
GDScript простые переписываемые функции.

Overrideable functions (переписываемые функции)
----------------------

Узлы предоставляют множество полезных переписываемых функций, 
которые описываются как:

::

    func _enter_tree():
        # Когда узел попадает в _Scene Tree_, он становится активным 
        # и эта функция вызывается. Дочерние узлы еще не вошли в активную сцену
        # В общем лучше использовать _ready() 
        # в большинстве случаев.
        pass

    func _ready():
        # Эта функция вызываетс япосле _enter_tree, но гарантирует 
        # что все дочерние узлы также вошли в _Scene Tree_, 
        # и стали активны.
        pass 

    func _exit_tree():
        # Когда узел выходит из _Scene Tree_, эта функция вызывается. 
        # Все дочерние узлы также вышли _Scene Tree_ и с этого момента 
        # неактивны.
        pass

    func _process(delta):
        # Когда set_process() включен, эта функция вызывается каждый кадр.
        pass

    func _fixed_process(delta):
        # Когда set_fixed_process() включен, она вызывается каждый физический кадр 
        pass

    func _paused():
        # Вызывается когда игра на паузе. После этого вызова, узел не получает 
        # больше process callbacks.
        pass

    func _unpaused():
        # Вызывается когда игра снимается с паузы.
        pass

Как упоминалось ранее, лучше использовать эти функции.

Создание узлов
--------------

Для создания узлов в коде, просто вызовите метод .new() (как для
любых других классов базовых типов). Пример:

::

    var s
    func _ready():
        s = Sprite.new() # создает новый спрайт!
        add_child(s) # добавляет его к потомкам этого узла

Для удаления узла, будь то внутри сцены или снаружи, используйте free() :

::

    func _someaction():
        s.free() # немедленно удаляет узел из сцены и освобождает его

Когда узел освобожден, он также освобождает всех своих потомков. 
Поэтому ручное удаление узлов гораздо проще чем кажется. 
Просто освободите базовый узел и все остальное в под-дереве уйдет вместе с ним.

Но, часто вы пытаетесь удалить узел который сейчас заблокирован
потому что он испускает сигнал или вызывает функцию.
Это крашит игру. Запуск Godot в режиме отладки часто перехватывает эту ситуацию
и предупреждает вас об этом.

Безопасный способ удаления узлов это:
:ref:`Node.queue_free() <class_Node_queue_free>`.
Это безопасно стирает узлы во время простоя.

::

    func _someaction():
        s.queue_free() # удаляет и уничтожает узел пока ничего не происходит

Инстанцирование сцен
-----------------

Инстанцирование сцен из кода очень просто и выполняется в два шага. 
Первый - загрузить сцену с диска.

::

    var scene = load("res://myscene.scn") # будет загружаться когда скрипт инстанцирован

Иногда предзагрузка бывает более удачным, как например во время парсинга.

::

    var scene = preload("res://myscene.scn") # загрузится при парсинге скрипта

Но 'scene' это не узел, соержащий под-узлы. Он упакован в специальный ресурс
называемый :ref:`PackedScene <class_PackedScene>`.
Для создания реального узла, нужно вызвать функцию
:ref:`PackedScene.instance() <class_PackedScene_instance>`
Она вернет дерево узлов которое может быть добавлено к активной сцене:

::

    var node = scene.instance()
    add_child(node)

Преимущество такого двух-этапного подхода в том упакованная сцена может
быть загружена и готова к использованию, поэтому может быть использована для создания
многих экземпляров. Это особенно полезно например для множества врагов, пуль и т.п.
в активной сцене.
