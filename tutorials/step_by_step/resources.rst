.. _doc_resources:

Ресурсы
=========

Узлы и ресурсы
-------------------

До сих пор, :ref:`Nodes <class_Node>`
был наиболее важным типом данных в Godot, поскольку большинство типов поведений
и фич движка реализованы через него. Но есть и другой тип данных, который не менее важен:
:ref:`Resource <class_Resource>`.

Если *Nodes* фокусируется на поведениях, таких как отрисовка спрайтов, 
3D моделей, физике, GUI контролах, и т.п.,

**Resources** это просто **data containers**. Это означает что они не делают
никаких действий и не обрабатывают каких либо данных. Resources просто
содержат данные.

Примеры resources 
:ref:`Texture <class_Texture>`,
:ref:`Script <class_Script>`,
:ref:`Mesh <class_Mesh>`,
:ref:`Animation <class_Animation>`,
:ref:`Sample <class_Sample>`,
:ref:`AudioStream <class_AudioStream>`,
:ref:`Font <class_Font>`,
:ref:`Translation <class_Translation>`,
и др.

Когда Godot сохраняет или загружает (с диска) сцену (.scn или .xml), изображения
(png, jpg), скрипта (.gd) или почти все, является файлом считается ресурсом.

Когда resource загружается с диска, **он всегда загружается один раз**. Что означает,
если есть копия этого ресурса уже загруженная в память,
при попытке загрузить ресурс будет всегда возвращаться уже загруженная копия.
это соответствует тому, что ресурсы это просто контейнеры данных,
поэтому нет необходимости дублировать их.

Обычно, каждый объект в Godot (Node, Resource, или что-то еще) может экспортировать свойства,
pсвойства могут быть разных типов (string,
integer, Vector2, и т.п) и один из этих типов может быть ресурс. Это означает что
и nodes и ресурсы могут содержать ресурсы как свойства.
Проиллюстрируем это:

.. image:: /img/nodes_resources.png

External или built-in
--------------------

Ресурсные свойства могут ссылаться на ресурсы двумя способами,
*external* (на диске) или **built-in**.

Более конкретно, вот :ref:`Texture <class_Texture>`
в :ref:`Sprite <class_Sprite>` узле:

.. image:: /img/spriteprop.png

Нажмите кнопку предварительного просмотра ">" справа позволяющую
просматривать и редактировать ресурсные свойства. Одно из свойств (path)
показывает, откуда он. В этом случае, он пришел из png изображения.

.. image:: /img/resourcerobi.png

Когда ресурс приходит из файла, Он считается *external* (внешним)
ресурсом. Если свойство path стереть (или если его и небыло), 
то ресурс считается встроенным (built-in).

Например, если путь \`"res://robi.png"\` стереть в свойстве "path"
в примере выше, и сохранить сцену, то ресурс будет сохранен внутри
 .scn файла, и болше не будет ссылаться на "robi.png". 
 Тем не менее, даже если сохранить ресурс как встроенный, и даже если сцена,
будет инстанцирована несколько раз, ресурс будет загружен лишь однажды.
Это означает, что, различные сцены Robi robot инстанцированные в одно и то же время
будут разделять одно и то-же изображение.

Загрузка ресурса в коде
---------------------------

Загружать ресурсы из кода - просто. Есть два способа сделать это. 
Первый это использовать функцию load(), вот так:

::

    func _ready():
            var res = load("res://robi.png") # resource is loaded when line is executed
            get_node("sprite").set_texture(res)

Второй способ более оптимальный, но работает только со строковыми константами
в параметре, поскольку загружает ресурсы во время компиляции.

::

    func _ready():
            var res = preload("res://robi.png") # ресурс загружается во время компиляции
            get_node("sprite").set_texture(res)

Загрузка сцен
--------------

Сцены также являются ресурсами, but there is a catch. Сцены сохраненные на диск,
являются ресурсами типа :ref:`PackedScene <class_PackedScene>`,
что означает что сцена упакована внутри ресурса.

Для получения экземпляра сцены, нужно использовать метод
:ref:`PackedScene.instance() <class_PackedScene_instance>`.

::

    func _on_shoot():
            var bullet = preload("res://bullet.scn").instance()
            add_child(bullet)                  

Этот метод создает иерархию узлов, конфигурирует их (устанавливает все свойства)
и возвращает корневой узел сцены, который можно добавлять к любому другому узлу.

Этот подход имеет ряд преимуществ. Поскольку функция
:ref:`PackedScene.instance() <class_PackedScene_instance>`
работает довольно быстро, добавление контента в сцену происходит эффективно.
Новые враги, пули, эффекты, и т.п. могут быть быстро добавлены или убраны
, без необходимости загружать их с диска снова всякий раз.
Важно помнить, что как и всегда, изображения, меши, и т.п.
все разделяемы между экземплярами сцены.

Освобождение ресурсов
-----------------

Resource extends от :ref:`Reference <class_Reference>`.
As such, когда ресурс больше неиспользуется, он автоматически освобождается.
Since, in most cases, Resources are contained in Nodes, scripts
or other resources, when a node is removed or freed, all the children
resources are freed too.

Скриптинг
---------

Как любой объект в Godot, не только узлы, ресурсы тоже можно скриптить.
Однако, обычно это не дает преимуществ поскольку ресурсы это только контейнеры данных.
